package db

import (
	"context"
	"database/sql"
	"fmt"
)

/*
store provides all functions to execute queries and transactions as well as their combination within a transaction
for individual queries we already have query struct which is generated by sqlc package.

all existing queries which are generated by sqlc as an struct only do one operation on one specific table.
so query struct does not support transaction. and that is why we have to expand it's functionality by embedding it inside a store struct.

this is called composition and it is the preferred way to extend struct functionality in Goland instead of inheritance!
by embedding queries inside strore all individual query functions provided by queries will be available to store.
*/

type Store struct {
	*Queries

	//we need below line to create a new db transaction
	db *sql.DB
}

func NewStore(db *sql.DB) *Store {
	return &Store{
		db:      db,
		Queries: New(db),
	}
}

// we made this function with lower case e to do not allow other packages to execute it directly and instead for each transaction we will call it inside the transaction
func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	tx, err := store.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	q := New(tx)
	err = fn(q)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("txErr: %v, rbErr: %v", err, rbErr)
		}
		return err
	}
	return tx.Commit()
}

// this struct contains neccessary input parameters for a transfer money to another account
type TransferTxParams struct {
	FromAccountID int64 `json:"from_account_id"`
	ToAccountID   int64 `json:"to_account_id"`
	Amount        int64 `json:"amount"`
}

type TransferTxResult struct {
	Transfers   Transfers `json:"transfers"`
	FromAccount Accounts  `json:"from_account_id"`
	ToAccount   Accounts  `json:"to_account_id"`
	FromEntry   Entries   `json:"from_entry"`
	ToEntry     Entries   `json:"to_entry"`
}

/*
	here is first version of our transaction to do a transfer money from one account to another account, so here as we can see in store_test.go comments
		we can see that how we fix our deadlock for the foreign account_id key. but we did not completely fix deadlock issue. the best way to do that is
		to avoid deadlock. so imagine a scenario that account1 send 10USD to account2 and as a concurrent transaction, account2 will send 10USD to account1.
		so new deadlock will happen. to avoid this issue again we will follow the TDD and fix this issue with the help of our unit tests and new transfer
		will implement bellow this old function. (IF WE HAVE 2 CONCURRENR TRANSACTIONS INVOLVING THE SAME PAIR OF ACCOUNTS, THERE MIGHT BE A POTENIAL DEADLOCK)
*/
// TransferTx performs a money transfer from one account to another account
// It creates a transfer record, add account entries, update acounts's balance within a single database transaction
// func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) {
// 	var result TransferTxResult
// 	err := store.execTx(context.Background(), func(q *Queries) error {
// 		var err error
// 		result.Transfers, err = q.CreateTransfer(ctx, CreateTransferParams{
// 			FromAccountID: arg.FromAccountID,
// 			ToAccountID:   arg.ToAccountID,
// 			Amount:        arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams{
// 			AccountID: arg.FromAccountID,
// 			Amount:    -arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams{
// 			AccountID: arg.ToAccountID,
// 			Amount:    arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		/*
// 			till now, we first wrote codes and then unit tests, since now we will do it in TDD
// 			 so first we wrote our tests with logics in store_test.go, then will come back here
// 			 to implement logics that pass those tests.

// 			to do so and pass the unit tests we wrote in store_test.go for update balance, we need to
// 			 update accounts. but the point is here, if we just get the balance for each account with
// 			 q.GetAccount(ctx, ...) and update them, the result is wrong and our unit tests will not
// 			 pass, because it gets wrong values for cuncurrent update requests. to fix this issue we
// 			 need to make another getAccount query which wait to update it's values for concurrent
// 			 requests, then when commit ran return the updated values for SELECT * query. therefore
// 			 we add a new query in ./db/query/account.sql for getAccountForUpdate and regenerate codes with sqlc
// 		*/

// 		// we discussed on store_test.go why we commented it and use the next method instead
// 		// account1, err := q.GetAccountForUpdate(ctx, arg.FromAccountID)
// 		// if err != nil {
// 		// 	return err
// 		// }
// 		// result.FromAccount, err = q.UpdateAccount(ctx, UpdateAccountParams{
// 		// 	ID:      arg.FromAccountID,
// 		// 	Balance: account1.Balance - arg.Amount,
// 		// })
// 		result.FromAccount, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
// 			ID:     arg.FromAccountID,
// 			Amount: -arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		// account2, err := q.GetAccountForUpdate(ctx, arg.ToAccountID)
// 		// if err != nil {
// 		// 	return err
// 		// }
// 		// result.ToAccount, err = q.UpdateAccount(ctx, UpdateAccountParams{
// 		// 	ID:      arg.ToAccountID,
// 		// 	Balance: account2.Balance + arg.Amount,
// 		// })
// 		result.ToAccount, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
// 			ID:     arg.ToAccountID,
// 			Amount: arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}

// 		return nil
// 	})
// 	return result, err
// }

// func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) {
// 	var result TransferTxResult
// 	err := store.execTx(context.Background(), func(q *Queries) error {
// 		var err error
// 		result.Transfers, err = q.CreateTransfer(ctx, CreateTransferParams{
// 			FromAccountID: arg.FromAccountID,
// 			ToAccountID:   arg.ToAccountID,
// 			Amount:        arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams{
// 			AccountID: arg.FromAccountID,
// 			Amount:    -arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams{
// 			AccountID: arg.ToAccountID,
// 			Amount:    arg.Amount,
// 		})
// 		if err != nil {
// 			return err
// 		}

// 		if arg.FromAccountID < arg.ToAccountID {
// 			result.FromAccount, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
// 				ID:     arg.FromAccountID,
// 				Amount: -arg.Amount,
// 			})
// 			if err != nil {
// 				return err
// 			}
// 			result.ToAccount, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
// 				ID:     arg.ToAccountID,
// 				Amount: arg.Amount,
// 			})
// 			if err != nil {
// 				return err
// 			}
// 		} else {
// 			result.ToAccount, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
// 				ID:     arg.ToAccountID,
// 				Amount: arg.Amount,
// 			})
// 			if err != nil {
// 				return err
// 			}
// 			result.FromAccount, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
// 				ID:     arg.FromAccountID,
// 				Amount: -arg.Amount,
// 			})
// 			if err != nil {
// 				return err
// 			}
// 		}

// 		return nil
// 	})
// 	return result, err
// }

// however we were done with implementations with the exact above codes, but in needs refactore, because it contains a lot of
//
//	duplicate codes. to do so, we will make a new function to update balance and add money to accounts for us
func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) {
	var result TransferTxResult
	err := store.execTx(context.Background(), func(q *Queries) error {
		var err error
		result.Transfers, err = q.CreateTransfer(ctx, CreateTransferParams{
			FromAccountID: arg.FromAccountID,
			ToAccountID:   arg.ToAccountID,
			Amount:        arg.Amount,
		})
		if err != nil {
			return err
		}
		result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams{
			AccountID: arg.FromAccountID,
			Amount:    -arg.Amount,
		})
		if err != nil {
			return err
		}
		result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams{
			AccountID: arg.ToAccountID,
			Amount:    arg.Amount,
		})
		if err != nil {
			return err
		}

		if arg.FromAccountID < arg.ToAccountID {
			result.FromAccount, result.ToAccount, err = addMoney(ctx, q, arg.FromAccountID, -arg.Amount, arg.ToAccountID, arg.Amount)
		} else {
			result.ToAccount, result.FromAccount, err = addMoney(ctx, q, arg.ToAccountID, +arg.Amount, arg.FromAccountID, -arg.Amount)
		}

		return nil
	})
	return result, err
}

func addMoney(ctx context.Context, q *Queries, accountID1 int64, amount1 int64, accountID2 int64, amount2 int64) (account1 Accounts, account2 Accounts, err error) {
	account1, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
		ID:     accountID1,
		Amount: amount1,
	})
	if err != nil {
		return // this is same as return account1, account2, err in shorter version
	}
	account2, err = q.AddAcountBalance(ctx, AddAcountBalanceParams{
		ID:     accountID2,
		Amount: amount2,
	})
	if err != nil {
		return
	}
	return
}
